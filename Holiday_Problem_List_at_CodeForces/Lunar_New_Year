import java.util.*;
public class Main {
    static final long P = 998244353L;
    static final long ORDER = P - 1;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int k = sc.nextInt();
        long[] b = new long[k];
        for (int i = 0; i < k; i++) b[i] = sc.nextLong() % ORDER;
        long n = sc.nextLong();
        long m = sc.nextLong();
        // build companion matrix and compute c = (M^(n-k))[0][0] mod ORDER
        long[][] M = new long[k][k];
        for (int j = 0; j < k; j++) M[0][j] = b[j] % ORDER;
        for (int i = 1; i < k; i++) M[i][i-1] = 1;
        long exp = n - k;
        long c;
        if (exp < 0) {
            // n <= k-1 but constraints say k < n, so not happen
            System.out.println(-1);
            return;
        } else if (exp == 0) {
            // M^0 => identity, so coefficient is 1 at [0][0] only when k==1, otherwise 0
            // For vector [e_k,0...], e_n = e_k if n==k
            // Here n>k so won't happen, but keep general:
            long[][] I = new long[k][k];
            for (int i = 0; i < k; i++) I[i][i] = 1;
            c = I[0][0] % ORDER;
        } else {
            long[][] R = matPow(M, exp, ORDER);
            c = R[0][0] % ORDER;
        }

        // discrete log: find t such that 3^t = m mod P
        long g = 3;
        long t;
        if (m == 1) {
            t = 0;
        } else {
            t = discreteLog(g, m, P);
            if (t == -1) { System.out.println(-1); return; }
        }

        long g0 = gcd(c, ORDER);
        if (t % g0 != 0) {
            System.out.println(-1);
            return;
        }
        long mod = ORDER / g0;
        long c2 = c / g0;
        long t2 = t / g0;
        long inv = modInverse(c2 % mod, mod);
        if (inv == -1) { System.out.println(-1); return; }
        long x = (mulMod(t2 % mod, inv, mod)) % mod; // solution modulo mod
        // compute fk = 3^x mod P
        long fk = modPow(g, x, P);
        System.out.println(fk);
    }

    static long[][] matMul(long[][] A, long[][] B, long mod) {
        int n = A.length;
        long[][] C = new long[n][n];
        for (int i = 0; i < n; i++) {
            for (int k = 0; k < n; k++) if (A[i][k] != 0) {
                long av = A[i][k];
                for (int j = 0; j < n; j++) {
                    C[i][j] = (C[i][j] + av * B[k][j]) % mod;
                }
            }
        }
        return C;
    }

    static long[][] matPow(long[][] M, long e, long mod) {
        int n = M.length;
        long[][] R = new long[n][n];
        for (int i = 0; i < n; i++) R[i][i] = 1;
        long[][] A = new long[n][n];
        for (int i = 0; i < n; i++) System.arraycopy(M[i], 0, A[i], 0, n);
        while (e > 0) {
            if ((e & 1) == 1) R = matMul(R, A, mod);
            A = matMul(A, A, mod);
            e >>= 1;
        }
        return R;
    }

    static long modPow(long a, long e, long mod) {
        long r = 1 % mod;
        a %= mod;
        while (e > 0) {
            if ((e & 1) == 1) r = (r * a) % mod;
            a = (a * a) % mod;
            e >>= 1;
        }
        return r;
    }

    static long gcd(long a, long b) {
        while (b != 0) {
            long t = a % b; a = b; b = t;
        }
        return a;
    }

    static long mulMod(long a, long b, long mod) {
        return (a * b) % mod;
    }

    static long modInverse(long a, long mod) {
        a = (a % mod + mod) % mod;
        long g = gcd(a, mod);
        if (g != 1) return -1;
        // pow a^(mod-2) mod mod if mod prime, but mod may not be prime. Use extended gcd.
        return extInv(a, mod);
    }

    static long extInv(long a, long m) {
        long[] res = extgcd(a, m);
        long g = res[0], x = res[1];
        if (g != 1) return -1;
        x %= m;
        if (x < 0) x += m;
        return x;
    }

    static long[] extgcd(long a, long b) {
        if (b == 0) return new long[]{a, 1, 0};
        long[] t = extgcd(b, a % b);
        long g = t[0], x = t[2], y = t[1] - (a / b) * t[2];
        return new long[]{g, x, y};
    }

    // baby-step giant-step to solve g^x = h mod p, returns x or -1
    static long discreteLog(long a, long b, long p) {
        a %= p; b %= p;
        if (b == 1) return 0;
        long cnt = 0;
        long t = 1;
        long g;
        while ((g = gcd(a, p)) > 1) {
            if (b == t) return cnt;
            if (b % g != 0) return -1;
            b /= g;
            p /= g;
            t = (t * (a / g)) % p;
            cnt++;
        }
        long m = (long) Math.ceil(Math.sqrt(p));
        Map<Long, Integer> vals = new HashMap<>();
        long base = 1;
        for (int j = 0; j < m; j++) {
            if (!vals.containsKey(base)) vals.put(base, j);
            base = (base * a) % p;
        }
        long factor = modPow(a, m, p);
        long cur = b;
        for (int i = 0; i <= m; i++) {
            Integer j = vals.get(cur);
            if (j != null) {
                long ans = i * m + j;
                return (ans + cnt) % (P - 1);
            }
            cur = (cur * modInverseNoCheck(factor, p)) % p;
        }
        return -1;
    }

    // inverse modulo p where p is prime or factor coprime
    static long modInverseNoCheck(long a, long p) {
        return modPow(a, p - 2, p);
    }
}
